// File automatically generated by wgsl_bindgen^
//
// ^ wgsl_bindgen version 0.21.3
// Changes made to this file will not be saved.
// SourceHash: 4c7e87740bdb0b7a4210356724809258956b6c081976b8461256e9340b56824a

#![allow(unused, non_snake_case, non_camel_case_types, non_upper_case_globals)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ShaderEntry {
    Common,
    Shape,
    AabbFrame,
    Bvh,
    Integration,
}
impl ShaderEntry {
    pub fn create_pipeline_layout(&self, device: &wgpu::Device) -> wgpu::PipelineLayout {
        match self {
            Self::Common => common::create_pipeline_layout(device),
            Self::Shape => shape::create_pipeline_layout(device),
            Self::AabbFrame => aabb_frame::create_pipeline_layout(device),
            Self::Bvh => bvh::create_pipeline_layout(device),
            Self::Integration => integration::create_pipeline_layout(device),
        }
    }
    pub fn create_shader_module_embed_source(&self, device: &wgpu::Device) -> wgpu::ShaderModule {
        match self {
            Self::Common => common::create_shader_module_embed_source(device),
            Self::Shape => shape::create_shader_module_embed_source(device),
            Self::AabbFrame => aabb_frame::create_shader_module_embed_source(device),
            Self::Bvh => bvh::create_shader_module_embed_source(device),
            Self::Integration => integration::create_shader_module_embed_source(device),
        }
    }
}
mod _root {
    pub use super::*;
    pub trait SetBindGroup {
        fn set_bind_group(&mut self, index: u32, bind_group: &wgpu::BindGroup, offsets: &[wgpu::DynamicOffset]);
    }
    impl SetBindGroup for wgpu::RenderPass<'_> {
        fn set_bind_group(&mut self, index: u32, bind_group: &wgpu::BindGroup, offsets: &[wgpu::DynamicOffset]) {
            self.set_bind_group(index, bind_group, offsets);
        }
    }
    impl SetBindGroup for wgpu::RenderBundleEncoder<'_> {
        fn set_bind_group(&mut self, index: u32, bind_group: &wgpu::BindGroup, offsets: &[wgpu::DynamicOffset]) {
            self.set_bind_group(index, bind_group, offsets);
        }
    }
    impl SetBindGroup for wgpu::ComputePass<'_> {
        fn set_bind_group(&mut self, index: u32, bind_group: &wgpu::BindGroup, offsets: &[wgpu::DynamicOffset]) {
            self.set_bind_group(index, bind_group, offsets);
        }
    }
}
pub mod layout_asserts {
    use super::{_root, _root::*};
    const WGSL_BASE_TYPE_ASSERTS: () = {};
    const COMMON_CAMERA_ASSERTS: () = {
        assert!(std::mem::offset_of!(common::Camera, inner) == 0);
        assert!(std::mem::size_of::<common::Camera>() == 64);
    };
    const COMMON_VELOCITY_ASSERTS: () = {
        assert!(std::mem::offset_of!(common::Velocity, inner) == 0);
        assert!(std::mem::size_of::<common::Velocity>() == 8);
    };
    const COMMON_FLAGS_ASSERTS: () = {
        assert!(std::mem::offset_of!(common::Flags, inner) == 0);
        assert!(std::mem::size_of::<common::Flags>() == 4);
    };
    const COMMON_COLOR_ASSERTS: () = {
        assert!(std::mem::offset_of!(common::Color, inner) == 0);
        assert!(std::mem::size_of::<common::Color>() == 16);
    };
    const COMMON_SHAPE_ASSERTS: () = {
        assert!(std::mem::offset_of!(common::Shape, inner) == 0);
        assert!(std::mem::size_of::<common::Shape>() == 4);
    };
    const COMMON_A_A_B_B_ASSERTS: () = {
        assert!(std::mem::offset_of!(common::AABB, min) == 0);
        assert!(std::mem::offset_of!(common::AABB, max) == 8);
        assert!(std::mem::size_of::<common::AABB>() == 16);
    };
    const COMMON_BVH_NODE_ASSERTS: () = {
        assert!(std::mem::offset_of!(common::BvhNode, index) == 0);
        assert!(std::mem::size_of::<common::BvhNode>() == 4);
    };
    const BVH_COMBINE_NODE_PASS_ASSERTS: () = {
        assert!(std::mem::offset_of!(bvh::CombineNodePass, src_start) == 0);
        assert!(std::mem::offset_of!(bvh::CombineNodePass, dst_start) == 4);
        assert!(std::mem::offset_of!(bvh::CombineNodePass, parent_count) == 8);
        assert!(std::mem::size_of::<bvh::CombineNodePass>() == 12);
    };
    const COMMON_MASS_ASSERTS: () = {
        assert!(std::mem::offset_of!(common::Mass, inner) == 0);
        assert!(std::mem::size_of::<common::Mass>() == 4);
    };
}
pub mod common {
    use super::{_root, _root::*};
    pub const FLAG_DRAW_OBJECT: u32 = 1u32;
    pub const FLAG_DRAW_AABB: u32 = 2u32;
    pub const FLAG_PHYSICAL: u32 = 4u32;
    pub const BVH_NODE_TREE_FLAG: u32 = 2147483648u32;
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Camera {
        #[doc = "offset: 0, size: 64, type: `mat4x4<f32>`"]
        pub inner: [[f32; 4]; 4],
    }
    impl Camera {
        pub const fn new(inner: [[f32; 4]; 4]) -> Self {
            Self { inner }
        }
    }
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Velocity {
        #[doc = "offset: 0, size: 8, type: `vec2<f32>`"]
        pub inner: [f32; 2],
    }
    impl Velocity {
        pub const fn new(inner: [f32; 2]) -> Self {
            Self { inner }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Flags {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub inner: u32,
    }
    impl Flags {
        pub const fn new(inner: u32) -> Self {
            Self { inner }
        }
    }
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Color {
        #[doc = "offset: 0, size: 16, type: `vec4<f32>`"]
        pub inner: [f32; 4],
    }
    impl Color {
        pub const fn new(inner: [f32; 4]) -> Self {
            Self { inner }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Shape {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub inner: u32,
    }
    impl Shape {
        pub const fn new(inner: u32) -> Self {
            Self { inner }
        }
    }
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct AABB {
        #[doc = "offset: 0, size: 8, type: `vec2<f32>`"]
        pub min: [f32; 2],
        #[doc = "offset: 8, size: 8, type: `vec2<f32>`"]
        pub max: [f32; 2],
    }
    impl AABB {
        pub const fn new(min: [f32; 2], max: [f32; 2]) -> Self {
            Self { min, max }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct BvhNode {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub index: u32,
    }
    impl BvhNode {
        pub const fn new(index: u32) -> Self {
            Self { index }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Mass {
        #[doc = "offset: 0, size: 4, type: `f32`"]
        pub inner: f32,
    }
    impl Mass {
        pub const fn new(inner: f32) -> Self {
            Self { inner }
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(entries: [wgpu::BindGroupLayout; 0]) -> [wgpu::BindGroupLayout; 0] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Common::PipelineLayout"),
            bind_group_layouts: &[],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("common.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct Camera {
    inner: mat4x4<f32>,
}

struct Velocity {
    inner: vec2<f32>,
}

struct Mass {
    inner: f32,
}

struct Flags {
    inner: u32,
}

struct Color {
    inner: vec4<f32>,
}

struct Shape {
    inner: u32,
}

struct AABB {
    min: vec2<f32>,
    max: vec2<f32>,
}

struct BvhNode {
    index: u32,
}

const UNIT_QUAD_VERTICES: array<vec2<f32>, 6> = array<vec2<f32>, 6>(vec2<f32>(0.5f, 0.5f), vec2<f32>(-0.5f, 0.5f), vec2<f32>(-0.5f, -0.5f), vec2<f32>(-0.5f, -0.5f), vec2<f32>(0.5f, -0.5f), vec2<f32>(0.5f, 0.5f));
const FLAG_DRAW_OBJECT: u32 = 1u;
const FLAG_DRAW_AABB: u32 = 2u;
const FLAG_PHYSICAL: u32 = 4u;
const BVH_NODE_TREE_FLAG: u32 = 2147483648u;

fn invocation_index(gid: vec3<u32>, workgroup_size: u32) -> u32 {
    return (gid.x + ((gid.y * 65535u) * workgroup_size));
}

"#;
}
pub mod bytemuck_impls {
    use super::{_root, _root::*};
    unsafe impl bytemuck::Zeroable for common::Camera {}
    unsafe impl bytemuck::Pod for common::Camera {}
    unsafe impl bytemuck::Zeroable for common::Velocity {}
    unsafe impl bytemuck::Pod for common::Velocity {}
    unsafe impl bytemuck::Zeroable for common::Flags {}
    unsafe impl bytemuck::Pod for common::Flags {}
    unsafe impl bytemuck::Zeroable for common::Color {}
    unsafe impl bytemuck::Pod for common::Color {}
    unsafe impl bytemuck::Zeroable for common::Shape {}
    unsafe impl bytemuck::Pod for common::Shape {}
    unsafe impl bytemuck::Zeroable for common::AABB {}
    unsafe impl bytemuck::Pod for common::AABB {}
    unsafe impl bytemuck::Zeroable for common::BvhNode {}
    unsafe impl bytemuck::Pod for common::BvhNode {}
    unsafe impl bytemuck::Zeroable for bvh::CombineNodePass {}
    unsafe impl bytemuck::Pod for bvh::CombineNodePass {}
    unsafe impl bytemuck::Zeroable for common::Mass {}
    unsafe impl bytemuck::Pod for common::Mass {}
}
pub mod shape {
    use super::{_root, _root::*};
    pub const SHAPE_RECT: u32 = 0u32;
    pub const SHAPE_CIRCLE: u32 = 1u32;
    pub const ENTRY_VS_MAIN: &str = "vs_main";
    pub const ENTRY_FS_MAIN: &str = "fs_main";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize> {
        pub entry_point: &'static str,
        pub buffers: [wgpu::VertexBufferLayout<'static>; N],
        pub constants: Vec<(&'static str, f64)>,
    }
    pub fn vertex_state<'a, const N: usize>(
        module: &'a wgpu::ShaderModule,
        entry: &'a VertexEntry<N>,
    ) -> wgpu::VertexState<'a> {
        wgpu::VertexState {
            module,
            entry_point: Some(entry.entry_point),
            buffers: &entry.buffers,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            },
        }
    }
    pub fn vs_main_entry() -> VertexEntry<0> {
        VertexEntry {
            entry_point: ENTRY_VS_MAIN,
            buffers: [],
            constants: Default::default(),
        }
    }
    #[derive(Debug)]
    pub struct FragmentEntry<const N: usize> {
        pub entry_point: &'static str,
        pub targets: [Option<wgpu::ColorTargetState>; N],
        pub constants: Vec<(&'static str, f64)>,
    }
    pub fn fragment_state<'a, const N: usize>(
        module: &'a wgpu::ShaderModule,
        entry: &'a FragmentEntry<N>,
    ) -> wgpu::FragmentState<'a> {
        wgpu::FragmentState {
            module,
            entry_point: Some(entry.entry_point),
            targets: &entry.targets,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            },
        }
    }
    pub fn fs_main_entry(targets: [Option<wgpu::ColorTargetState>; 1]) -> FragmentEntry<1> {
        FragmentEntry {
            entry_point: ENTRY_FS_MAIN,
            targets,
            constants: Default::default(),
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub camera: wgpu::BufferBinding<'a>,
        pub size_factor: wgpu::BufferBinding<'a>,
        pub flags: wgpu::BufferBinding<'a>,
        pub aabbs: wgpu::BufferBinding<'a>,
        pub colors: wgpu::BufferBinding<'a>,
        pub shapes: wgpu::BufferBinding<'a>,
        pub velocities: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub camera: wgpu::BindGroupEntry<'a>,
        pub size_factor: wgpu::BindGroupEntry<'a>,
        pub flags: wgpu::BindGroupEntry<'a>,
        pub aabbs: wgpu::BindGroupEntry<'a>,
        pub colors: wgpu::BindGroupEntry<'a>,
        pub shapes: wgpu::BindGroupEntry<'a>,
        pub velocities: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                camera: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.camera),
                },
                size_factor: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.size_factor),
                },
                flags: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.flags),
                },
                aabbs: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.aabbs),
                },
                colors: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.colors),
                },
                shapes: wgpu::BindGroupEntry {
                    binding: 5,
                    resource: wgpu::BindingResource::Buffer(params.shapes),
                },
                velocities: wgpu::BindGroupEntry {
                    binding: 6,
                    resource: wgpu::BindingResource::Buffer(params.velocities),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
            [
                self.camera,
                self.size_factor,
                self.flags,
                self.aabbs,
                self.colors,
                self.shapes,
                self.velocities,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
            label: Some("Shape::BindGroup0::LayoutDescriptor"),
            entries: &[
                #[doc = " @binding(0): \"camera\""]
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<_root::common::Camera>() as _),
                    },
                    count: None,
                },
                #[doc = " @binding(1): \"size_factor\""]
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<f32>() as _),
                    },
                    count: None,
                },
                #[doc = " @binding(2): \"flags\""]
                wgpu::BindGroupLayoutEntry {
                    binding: 2,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: true },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                #[doc = " @binding(3): \"aabbs\""]
                wgpu::BindGroupLayoutEntry {
                    binding: 3,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: true },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                #[doc = " @binding(4): \"colors\""]
                wgpu::BindGroupLayoutEntry {
                    binding: 4,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: true },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                #[doc = " @binding(5): \"shapes\""]
                wgpu::BindGroupLayoutEntry {
                    binding: 5,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: true },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                #[doc = " @binding(6): \"velocities\""]
                wgpu::BindGroupLayoutEntry {
                    binding: 6,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: true },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
            ],
        };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Shape::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(entries: [wgpu::BindGroupLayout; 1]) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Shape::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("shape.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct CameraX_naga_oil_mod_XMNXW23LPNYX {
    inner: mat4x4<f32>,
}

struct VelocityX_naga_oil_mod_XMNXW23LPNYX {
    inner: vec2<f32>,
}

struct FlagsX_naga_oil_mod_XMNXW23LPNYX {
    inner: u32,
}

struct ColorX_naga_oil_mod_XMNXW23LPNYX {
    inner: vec4<f32>,
}

struct ShapeX_naga_oil_mod_XMNXW23LPNYX {
    inner: u32,
}

struct AABBX_naga_oil_mod_XMNXW23LPNYX {
    min: vec2<f32>,
    max: vec2<f32>,
}

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) quad_position: vec2<f32>,
    @location(1) color: vec4<f32>,
    @location(2) @interpolate(flat) shape: u32,
}

struct FragmentOutput {
    @location(0) color: vec4<f32>,
}

const UNIT_QUAD_VERTICESX_naga_oil_mod_XMNXW23LPNYX: array<vec2<f32>, 6> = array<vec2<f32>, 6>(vec2<f32>(0.5f, 0.5f), vec2<f32>(-0.5f, 0.5f), vec2<f32>(-0.5f, -0.5f), vec2<f32>(-0.5f, -0.5f), vec2<f32>(0.5f, -0.5f), vec2<f32>(0.5f, 0.5f));
const FLAG_DRAW_OBJECTX_naga_oil_mod_XMNXW23LPNYX: u32 = 1u;
const SHAPE_RECT: u32 = 0u;
const SHAPE_CIRCLE: u32 = 1u;

@group(0) @binding(0) 
var<uniform> camera: CameraX_naga_oil_mod_XMNXW23LPNYX;
@group(0) @binding(1) 
var<uniform> size_factor: f32;
@group(0) @binding(2) 
var<storage> flags: array<FlagsX_naga_oil_mod_XMNXW23LPNYX>;
@group(0) @binding(3) 
var<storage> aabbs: array<AABBX_naga_oil_mod_XMNXW23LPNYX>;
@group(0) @binding(4) 
var<storage> colors: array<ColorX_naga_oil_mod_XMNXW23LPNYX>;
@group(0) @binding(5) 
var<storage> shapes: array<ShapeX_naga_oil_mod_XMNXW23LPNYX>;
@group(0) @binding(6) 
var<storage> velocities: array<VelocityX_naga_oil_mod_XMNXW23LPNYX>;

fn wavelength_to_rgb(lambda: f32) -> vec3<f32> {
    var r: f32 = 0f;
    var g: f32 = 0f;
    var b: f32 = 0f;

    if ((lambda >= 380f) && (lambda < 440f)) {
        r = (-((lambda - 440f)) / 60f);
        b = 1f;
    } else {
        if (lambda < 490f) {
            g = ((lambda - 440f) / 50f);
            b = 1f;
        } else {
            if (lambda < 510f) {
                g = 1f;
                b = (-((lambda - 510f)) / 20f);
            } else {
                if (lambda < 580f) {
                    r = ((lambda - 510f) / 70f);
                    g = 1f;
                } else {
                    if (lambda < 645f) {
                        r = 1f;
                        g = (-((lambda - 645f)) / 65f);
                    } else {
                        if (lambda <= 700f) {
                            r = 1f;
                        }
                    }
                }
            }
        }
    }
    let _e49 = r;
    let _e50 = g;
    let _e51 = b;
    return vec3<f32>(_e49, _e50, _e51);
}

fn spectral_intensity(lambda_1: f32) -> f32 {
    if (lambda_1 < 420f) {
        return (0.3f + ((0.7f * (lambda_1 - 380f)) / 40f));
    }
    if (lambda_1 > 645f) {
        return (0.3f + ((0.7f * (700f - lambda_1)) / 55f));
    }
    return 1f;
}

fn velocity_to_color(velocity: vec2<f32>, max_speed: f32) -> vec4<f32> {
    let speed = length(velocity);
    let t = clamp((speed / max_speed), 0f, 1f);
    let lambda_2 = mix(700f, 380f, t);
    let _e10 = wavelength_to_rgb(lambda_2);
    let _e11 = spectral_intensity(lambda_2);
    return vec4<f32>(((_e10 * _e11) * 0.8f), 0.1f);
}

fn sdf_cirle(p: vec2<f32>) -> f32 {
    return (length(p) - 0.5f);
}

@vertex 
fn vs_main(@builtin(vertex_index) vertex_index: u32, @builtin(instance_index) i: u32) -> VertexOutput {
    var out: VertexOutput = VertexOutput();
    var v: vec2<f32>;

    let _e5 = flags[i].inner;
    if ((_e5 & FLAG_DRAW_OBJECTX_naga_oil_mod_XMNXW23LPNYX) == 0u) {
        let _e11 = out;
        return _e11;
    }
    let aabb = aabbs[i];
    let _e19 = size_factor;
    let scale = ((aabb.max - aabb.min) * _e19);
    let center = ((aabb.min + aabb.max) / vec2(2f));
    let model = mat4x4<f32>(vec4<f32>(scale.x, 0f, 0f, 0f), vec4<f32>(0f, scale.y, 0f, 0f), vec4<f32>(0f, 0f, 1f, 0f), vec4<f32>(center.x, center.y, 0f, 1f));
    let vertex = UNIT_QUAD_VERTICESX_naga_oil_mod_XMNXW23LPNYX[vertex_index];
    let _e54 = camera.inner;
    out.clip_position = ((_e54 * model) * vec4<f32>(vertex, 0f, 1f));
    out.quad_position = vertex;
    let _e64 = velocities[i].inner;
    v = _e64;
    let _e67 = v;
    let _e69 = velocity_to_color(_e67, 6400f);
    out.color = _e69;
    let _e74 = shapes[i].inner;
    out.shape = _e74;
    let _e75 = out;
    return _e75;
}

@fragment 
fn fs_main(in: VertexOutput) -> FragmentOutput {
    var color: vec4<f32>;

    color = in.color;
    let _e4 = sdf_cirle(in.quad_position);
    let _e5 = fwidth(_e4);
    let w = (_e5 / 2f);
    if (in.shape == SHAPE_CIRCLE) {
        let _e14 = color.w;
        color.w = (_e14 * smoothstep(w, -(w), _e4));
    }
    let _e16 = color;
    return FragmentOutput(_e16);
}
"#;
}
pub mod aabb_frame {
    use super::{_root, _root::*};
    pub const ENTRY_VS_MAIN: &str = "vs_main";
    pub const ENTRY_FS_MAIN: &str = "fs_main";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize> {
        pub entry_point: &'static str,
        pub buffers: [wgpu::VertexBufferLayout<'static>; N],
        pub constants: Vec<(&'static str, f64)>,
    }
    pub fn vertex_state<'a, const N: usize>(
        module: &'a wgpu::ShaderModule,
        entry: &'a VertexEntry<N>,
    ) -> wgpu::VertexState<'a> {
        wgpu::VertexState {
            module,
            entry_point: Some(entry.entry_point),
            buffers: &entry.buffers,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            },
        }
    }
    pub fn vs_main_entry() -> VertexEntry<0> {
        VertexEntry {
            entry_point: ENTRY_VS_MAIN,
            buffers: [],
            constants: Default::default(),
        }
    }
    #[derive(Debug)]
    pub struct FragmentEntry<const N: usize> {
        pub entry_point: &'static str,
        pub targets: [Option<wgpu::ColorTargetState>; N],
        pub constants: Vec<(&'static str, f64)>,
    }
    pub fn fragment_state<'a, const N: usize>(
        module: &'a wgpu::ShaderModule,
        entry: &'a FragmentEntry<N>,
    ) -> wgpu::FragmentState<'a> {
        wgpu::FragmentState {
            module,
            entry_point: Some(entry.entry_point),
            targets: &entry.targets,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            },
        }
    }
    pub fn fs_main_entry(targets: [Option<wgpu::ColorTargetState>; 1]) -> FragmentEntry<1> {
        FragmentEntry {
            entry_point: ENTRY_FS_MAIN,
            targets,
            constants: Default::default(),
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub camera: wgpu::BufferBinding<'a>,
        pub flags: wgpu::BufferBinding<'a>,
        pub aabbs: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub camera: wgpu::BindGroupEntry<'a>,
        pub flags: wgpu::BindGroupEntry<'a>,
        pub aabbs: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                camera: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.camera),
                },
                flags: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.flags),
                },
                aabbs: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.aabbs),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.camera, self.flags, self.aabbs]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
            label: Some("AabbFrame::BindGroup0::LayoutDescriptor"),
            entries: &[
                #[doc = " @binding(0): \"camera\""]
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<_root::common::Camera>() as _),
                    },
                    count: None,
                },
                #[doc = " @binding(1): \"flags\""]
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: true },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                #[doc = " @binding(2): \"aabbs\""]
                wgpu::BindGroupLayoutEntry {
                    binding: 2,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: true },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
            ],
        };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("AabbFrame::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(entries: [wgpu::BindGroupLayout; 1]) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("AabbFrame::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("aabb_frame.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct CameraX_naga_oil_mod_XMNXW23LPNYX {
    inner: mat4x4<f32>,
}

struct FlagsX_naga_oil_mod_XMNXW23LPNYX {
    inner: u32,
}

struct AABBX_naga_oil_mod_XMNXW23LPNYX {
    min: vec2<f32>,
    max: vec2<f32>,
}

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) @interpolate(flat) flags: u32,
    @location(1) scale: f32,
    @location(2) quad_position: vec2<f32>,
}

struct FragmentOutput {
    @location(0) color: vec4<f32>,
}

const FLAG_DRAW_AABBX_naga_oil_mod_XMNXW23LPNYX: u32 = 2u;
const UNIT_QUAD_VERTICES: array<vec2<f32>, 5> = array<vec2<f32>, 5>(vec2<f32>(0.5f, 0.5f), vec2<f32>(-0.5f, 0.5f), vec2<f32>(-0.5f, -0.5f), vec2<f32>(0.5f, -0.5f), vec2<f32>(0.5f, 0.5f));

@group(0) @binding(0) 
var<uniform> camera: CameraX_naga_oil_mod_XMNXW23LPNYX;
@group(0) @binding(1) 
var<storage> flags_1: array<FlagsX_naga_oil_mod_XMNXW23LPNYX>;
@group(0) @binding(2) 
var<storage> aabbs: array<AABBX_naga_oil_mod_XMNXW23LPNYX>;

@vertex 
fn vs_main(@builtin(vertex_index) vertex_index: u32, @builtin(instance_index) i: u32) -> VertexOutput {
    var out: VertexOutput = VertexOutput();
    var flags: u32 = FLAG_DRAW_AABBX_naga_oil_mod_XMNXW23LPNYX;

    if (i < arrayLength((&flags_1))) {
        let _e9 = flags_1[i].inner;
        flags = _e9;
        let _e11 = flags;
        if ((_e11 & FLAG_DRAW_AABBX_naga_oil_mod_XMNXW23LPNYX) == 0u) {
            let _e17 = out;
            return _e17;
        }
    }
    let aabb = aabbs[i];
    let scale = (aabb.max - aabb.min);
    let center = ((aabb.min + aabb.max) / vec2(2f));
    let model = mat4x4<f32>(vec4<f32>(scale.x, 0f, 0f, 0f), vec4<f32>(0f, scale.y, 0f, 0f), vec4<f32>(0f, 0f, 1f, 0f), vec4<f32>(center.x, center.y, 0f, 1f));
    let vertex = UNIT_QUAD_VERTICES[vertex_index];
    let _e57 = camera.inner;
    out.clip_position = ((_e57 * model) * vec4<f32>(vertex, 0f, 1f));
    let _e64 = flags;
    out.flags = _e64;
    out.scale = max(scale.x, scale.y);
    out.quad_position = vertex;
    let _e70 = out;
    return _e70;
}

@fragment 
fn fs_main(in: VertexOutput) -> FragmentOutput {
    if ((in.flags & FLAG_DRAW_AABBX_naga_oil_mod_XMNXW23LPNYX) == 0u) {
        discard;
    }
    let intensity = min(1f, (length(in.scale) / 2000f));
    return FragmentOutput(vec4<f32>(intensity, intensity, intensity, intensity));
}
"#;
}
pub mod bvh {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct CombineNodePass {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub src_start: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub dst_start: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub parent_count: u32,
    }
    impl CombineNodePass {
        pub const fn new(src_start: u32, dst_start: u32, parent_count: u32) -> Self {
            Self {
                src_start,
                dst_start,
                parent_count,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const COMBINE_NODES_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_combine_nodes_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline combine_nodes"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("combine_nodes"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_COMBINE_NODES: &str = "combine_nodes";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub aabbs: wgpu::BufferBinding<'a>,
        pub nodes: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub aabbs: wgpu::BindGroupEntry<'a>,
        pub nodes: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                aabbs: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.aabbs),
                },
                nodes: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.nodes),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
            [self.aabbs, self.nodes]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
            label: Some("Bvh::BindGroup0::LayoutDescriptor"),
            entries: &[
                #[doc = " @binding(0): \"aabbs\""]
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::COMPUTE,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: false },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                #[doc = " @binding(1): \"nodes\""]
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility: wgpu::ShaderStages::COMPUTE,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: false },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
            ],
        };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Bvh::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(entries: [wgpu::BindGroupLayout; 1]) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Bvh::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[wgpu::PushConstantRange {
                stages: wgpu::ShaderStages::COMPUTE,
                range: 0..12,
            }],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("bvh.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct AABBX_naga_oil_mod_XMNXW23LPNYX {
    min: vec2<f32>,
    max: vec2<f32>,
}

struct BvhNodeX_naga_oil_mod_XMNXW23LPNYX {
    index: u32,
}

struct CombineNodePass {
    src_start: u32,
    dst_start: u32,
    parent_count: u32,
}

const BVH_NODE_TREE_FLAGX_naga_oil_mod_XMNXW23LPNYX: u32 = 2147483648u;
const WORKGROUP_SIZE: u32 = 64u;

var<push_constant> params: CombineNodePass;
@group(0) @binding(0) 
var<storage, read_write> aabbs: array<AABBX_naga_oil_mod_XMNXW23LPNYX>;
@group(0) @binding(1) 
var<storage, read_write> nodes: array<BvhNodeX_naga_oil_mod_XMNXW23LPNYX>;

fn invocation_indexX_naga_oil_mod_XMNXW23LPNYX(gid_1: vec3<u32>, workgroup_size: u32) -> u32 {
    return (gid_1.x + ((gid_1.y * 65535u) * workgroup_size));
}

@compute @workgroup_size(64, 1, 1) 
fn combine_nodes(@builtin(global_invocation_id) gid: vec3<u32>) {
    let _e2 = invocation_indexX_naga_oil_mod_XMNXW23LPNYX(gid, WORKGROUP_SIZE);
    let _e5 = params.parent_count;
    if (_e2 >= _e5) {
        return;
    }
    let _e9 = params.src_start;
    let src = (_e9 + (_e2 * 2u));
    let _e15 = params.dst_start;
    let dst = (_e15 + _e2);
    nodes[dst] = BvhNodeX_naga_oil_mod_XMNXW23LPNYX((src | BVH_NODE_TREE_FLAGX_naga_oil_mod_XMNXW23LPNYX));
    let left_aabb = aabbs[src];
    let right_aabb = aabbs[(src + 1u)];
    let aabb_min = min(left_aabb.min, right_aabb.min);
    let aabb_max = max(left_aabb.max, right_aabb.max);
    aabbs[dst] = AABBX_naga_oil_mod_XMNXW23LPNYX(aabb_min, aabb_max);
    return;
}
"#;
}
pub mod integration {
    use super::{_root, _root::*};
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub const BLACKHOLE_COUNT: u32 = 5u32;
    pub const BLACKHOLE_MASS_SCALE: f32 = 5000f32;
    pub const BLACKHOLE_SIZE_SCALE: f32 = 10f32;
    pub const BLACKHOLE_DESTROY_MATTER: bool = true;
    pub const GRAVITATIONAL_CONSTANT: f32 = 100000f32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const CS_MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_cs_main_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline cs_main"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("cs_main"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_CS_MAIN: &str = "cs_main";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub dt: wgpu::BufferBinding<'a>,
        pub flags: wgpu::BufferBinding<'a>,
        pub masses: wgpu::BufferBinding<'a>,
        pub velocities: wgpu::BufferBinding<'a>,
        pub aabbs: wgpu::BufferBinding<'a>,
        pub nodes: wgpu::BufferBinding<'a>,
        pub force_acc: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub dt: wgpu::BindGroupEntry<'a>,
        pub flags: wgpu::BindGroupEntry<'a>,
        pub masses: wgpu::BindGroupEntry<'a>,
        pub velocities: wgpu::BindGroupEntry<'a>,
        pub aabbs: wgpu::BindGroupEntry<'a>,
        pub nodes: wgpu::BindGroupEntry<'a>,
        pub force_acc: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                dt: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.dt),
                },
                flags: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.flags),
                },
                masses: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.masses),
                },
                velocities: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.velocities),
                },
                aabbs: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.aabbs),
                },
                nodes: wgpu::BindGroupEntry {
                    binding: 5,
                    resource: wgpu::BindingResource::Buffer(params.nodes),
                },
                force_acc: wgpu::BindGroupEntry {
                    binding: 6,
                    resource: wgpu::BindingResource::Buffer(params.force_acc),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
            [
                self.dt,
                self.flags,
                self.masses,
                self.velocities,
                self.aabbs,
                self.nodes,
                self.force_acc,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
            label: Some("Integration::BindGroup0::LayoutDescriptor"),
            entries: &[
                #[doc = " @binding(0): \"dt\""]
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::COMPUTE,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<f32>() as _),
                    },
                    count: None,
                },
                #[doc = " @binding(1): \"flags\""]
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility: wgpu::ShaderStages::COMPUTE,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: false },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                #[doc = " @binding(2): \"masses\""]
                wgpu::BindGroupLayoutEntry {
                    binding: 2,
                    visibility: wgpu::ShaderStages::COMPUTE,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: true },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                #[doc = " @binding(3): \"velocities\""]
                wgpu::BindGroupLayoutEntry {
                    binding: 3,
                    visibility: wgpu::ShaderStages::COMPUTE,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: false },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                #[doc = " @binding(4): \"aabbs\""]
                wgpu::BindGroupLayoutEntry {
                    binding: 4,
                    visibility: wgpu::ShaderStages::COMPUTE,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: false },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                #[doc = " @binding(5): \"nodes\""]
                wgpu::BindGroupLayoutEntry {
                    binding: 5,
                    visibility: wgpu::ShaderStages::COMPUTE,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: true },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                #[doc = " @binding(6): \"force_acc\""]
                wgpu::BindGroupLayoutEntry {
                    binding: 6,
                    visibility: wgpu::ShaderStages::COMPUTE,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: false },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
            ],
        };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Integration::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(entries: [wgpu::BindGroupLayout; 1]) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Integration::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("integration.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct VelocityX_naga_oil_mod_XMNXW23LPNYX {
    inner: vec2<f32>,
}

struct MassX_naga_oil_mod_XMNXW23LPNYX {
    inner: f32,
}

struct FlagsX_naga_oil_mod_XMNXW23LPNYX {
    inner: u32,
}

struct AABBX_naga_oil_mod_XMNXW23LPNYX {
    min: vec2<f32>,
    max: vec2<f32>,
}

struct BvhNodeX_naga_oil_mod_XMNXW23LPNYX {
    index: u32,
}

struct BlackHole {
    position: vec2<f32>,
    radius: f32,
    mass: f32,
    spin: f32,
}

struct IntegratedParameters {
    x: vec2<f32>,
    v: vec2<f32>,
}

const FLAG_DRAW_OBJECTX_naga_oil_mod_XMNXW23LPNYX: u32 = 1u;
const FLAG_DRAW_AABBX_naga_oil_mod_XMNXW23LPNYX: u32 = 2u;
const FLAG_PHYSICALX_naga_oil_mod_XMNXW23LPNYX: u32 = 4u;
const WORKGROUP_SIZE: u32 = 64u;
const BLACKHOLE_COUNT: u32 = 5u;
const BLACKHOLES: array<BlackHole, 5> = array<BlackHole, 5>(BlackHole(vec2<f32>(-200f, 500f), 1f, 4f, 0f), BlackHole(vec2<f32>(500f, 200f), 1f, 2f, 0f), BlackHole(vec2<f32>(), 3f, 10f, 1000f), BlackHole(vec2<f32>(-600f, -300f), 1f, 2f, 0f), BlackHole(vec2<f32>(600f, -700f), 1f, 4f, -100f));
const BLACKHOLE_MASS_SCALE: f32 = 5000f;
const BLACKHOLE_SIZE_SCALE: f32 = 10f;
const BLACKHOLE_DESTROY_MATTER: bool = true;
const GRAVITATIONAL_CONSTANT: f32 = 100000f;

@group(0) @binding(0) 
var<uniform> dt: f32;
@group(0) @binding(1) 
var<storage, read_write> flags: array<FlagsX_naga_oil_mod_XMNXW23LPNYX>;
@group(0) @binding(2) 
var<storage> masses: array<MassX_naga_oil_mod_XMNXW23LPNYX>;
@group(0) @binding(3) 
var<storage, read_write> velocities: array<VelocityX_naga_oil_mod_XMNXW23LPNYX>;
@group(0) @binding(4) 
var<storage, read_write> aabbs: array<AABBX_naga_oil_mod_XMNXW23LPNYX>;
@group(0) @binding(5) 
var<storage> nodes: array<BvhNodeX_naga_oil_mod_XMNXW23LPNYX>;
@group(0) @binding(6) 
var<storage, read_write> force_acc: array<vec2<f32>>;

fn invocation_indexX_naga_oil_mod_XMNXW23LPNYX(gid_1: vec3<u32>, workgroup_size: u32) -> u32 {
    return (gid_1.x + ((gid_1.y * 65535u) * workgroup_size));
}

fn blackhole_gravity(blackhole: BlackHole, position: vec2<f32>) -> vec2<f32> {
    let to_blackhole = (blackhole.position - position);
    let direction = normalize(to_blackhole);
    let distance = length(to_blackhole);
    let bh_gravity = ((((direction * GRAVITATIONAL_CONSTANT) * blackhole.mass) * BLACKHOLE_MASS_SCALE) / vec2((distance * distance)));
    return bh_gravity;
}

fn frame_dragging(blackhole_1: BlackHole, position_1: vec2<f32>, velocity: vec2<f32>) -> vec2<f32> {
    let rel = (blackhole_1.position - position_1);
    let r = length(rel);
    let angular_momentum = (blackhole_1.spin * vec2<f32>(1f, 1f));
    let vr_cross = cross(vec3<f32>(velocity, 0f), vec3<f32>(rel, 0f)).z;
    let vj_cross = cross(vec3<f32>(velocity, 0f), vec3<f32>(angular_momentum, 0f)).z;
    let a = ((200000f / pow(r, 3f)) * (vec2(vj_cross) - ((((3f * rel) * angular_momentum) * vr_cross) / vec2(pow(r, 2f)))));
    return a;
}

fn forces(position_2: vec2<f32>, velocity_1: vec2<f32>) -> vec2<f32> {
    var acc: vec2<f32> = vec2<f32>();
    var bh_index_1: u32 = 0u;

    loop {
        let _e3 = bh_index_1;
        if (_e3 < BLACKHOLE_COUNT) {
        } else {
            break;
        }
        {
            let _e7 = bh_index_1;
            let blackhole_2 = BLACKHOLES[_e7];
            let _e10 = blackhole_gravity(blackhole_2, position_2);
            let _e12 = acc;
            acc = (_e12 + _e10);
            let _e15 = frame_dragging(blackhole_2, position_2, velocity_1);
            let _e16 = acc;
            acc = (_e16 + _e15);
        }
        continuing {
            let _e19 = bh_index_1;
            bh_index_1 = (_e19 + 1u);
        }
    }
    let _e21 = acc;
    return _e21;
}

fn leapfrog_step(params_1: IntegratedParameters, w: f32) -> IntegratedParameters {
    var x: vec2<f32>;

    let _e2 = dt;
    let half_step = ((w * _e2) * 0.5f);
    x = (params_1.x + (params_1.v * half_step));
    let _e12 = x;
    let _e14 = forces(_e12, params_1.v);
    let _e17 = dt;
    let v = (params_1.v + (_e14 * (w * _e17)));
    let _e21 = x;
    x = (_e21 + (v * half_step));
    let _e24 = x;
    return IntegratedParameters(_e24, v);
}

fn integrate_yoshida(params_2: IntegratedParameters) -> IntegratedParameters {
    var p: IntegratedParameters;

    p = params_2;
    let _e2 = p;
    let _e4 = leapfrog_step(_e2, 1.3512071f);
    p = _e4;
    let _e5 = p;
    let _e7 = leapfrog_step(_e5, -1.7024144f);
    p = _e7;
    let _e8 = p;
    let _e10 = leapfrog_step(_e8, 1.3512071f);
    p = _e10;
    let _e11 = p;
    return _e11;
}

@compute @workgroup_size(64, 1, 1) 
fn cs_main(@builtin(global_invocation_id) gid: vec3<u32>) {
    var f: u32;
    var params: IntegratedParameters;
    var bh_index: u32 = 0u;

    let _e3 = invocation_indexX_naga_oil_mod_XMNXW23LPNYX(gid, WORKGROUP_SIZE);
    if (_e3 >= arrayLength((&masses))) {
        return;
    }
    let _e10 = flags[_e3].inner;
    f = _e10;
    let _e12 = f;
    if ((_e12 & FLAG_PHYSICALX_naga_oil_mod_XMNXW23LPNYX) == 0u) {
        return;
    }
    let aabb = aabbs[_e3];
    let start_x = ((aabb.min + aabb.max) / vec2(2f));
    let _e29 = velocities[_e3].inner;
    params = IntegratedParameters(start_x, _e29);
    let _e32 = params;
    let _e33 = integrate_yoshida(_e32);
    params = _e33;
    let size = (aabb.max - aabb.min);
    if BLACKHOLE_DESTROY_MATTER {
        loop {
            let _e39 = bh_index;
            let _e42 = f;
            if ((_e39 < BLACKHOLE_COUNT) && ((_e42 & FLAG_PHYSICALX_naga_oil_mod_XMNXW23LPNYX) != 0u)) {
            } else {
                break;
            }
            {
                let _e49 = bh_index;
                let blackhole_3 = BLACKHOLES[_e49];
                let _e53 = params.x;
                let distance_1 = (length((blackhole_3.position - _e53)) - (max(size.x, size.y) / 2f));
                if (distance_1 < (blackhole_3.radius * BLACKHOLE_SIZE_SCALE)) {
                    let _e67 = f;
                    f = (_e67 & 4294967288u);
                    params.v = vec2<f32>();
                }
            }
            continuing {
                let _e72 = bh_index;
                bh_index = (_e72 + 1u);
            }
        }
    }
    let _e77 = f;
    flags[_e3].inner = _e77;
    let _e82 = params.v;
    velocities[_e3].inner = _e82;
    let _e84 = params.x;
    let offset = (_e84 - start_x);
    aabbs[_e3] = AABBX_naga_oil_mod_XMNXW23LPNYX((aabb.min + offset), (aabb.max + offset));
    return;
}
"#;
}
